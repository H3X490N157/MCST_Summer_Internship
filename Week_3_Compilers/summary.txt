Это просто конспект теоретического материала с расписанными ответами на вопросы зачёта. Часть информации к ответам на зачёт будут брать отсюда (привет тому, кто это читает):

Вопрос 1. Общее устройство компилятора

Сама система компиляции (тулчейн) состоит из 3 основных элементов: самого компилятора, ассемблера и линкера. Сам компилятор при этом также делится на три части: фронтенд, миддленд и бэкенд, иногда миддленд считают частью фронтенда (вроде, устаревший подход). Лицевая часть компилятора (фротенд) получает код и выполняет три основных анализа: лексический, синтаксический и семантический. Лексический анализ выделяет основные лексемы (токены) из кода. В большинстве компиляторов токены представляют из себя пару вида "тип токена(например, тип данных, название переменной, rvalue-число и т.д.) + значение". Далее идёт синтаческий анализ/парсинг: происходит анализ потока лексем и построение на его основе AST - Abstract Syntax Tree/Синтаксического Дерево. Построение может быть неявным. Паралеллельно с синтаксическим анализом идёт семантический анализ: с помощью семантического анализатора, который оперерирует сохранённым контекстом на частичном AST, определяет, каким должен быть следующий узео, после чего в случае нарушения логики выдаёт сообщение о семантической ошибке. Затем идёт перевод AST в промежуточное представление (которое бывает двух видов - высокоуровневое HIR и низкоуровневое LIR, необходимые для машинно-независимых и машинно-зависимых оптимизаций соответственно). Сначала происходит перевод AST в HIR. В миддленде компилятора выполняются оптимизации для HIR (несколько проходов по коду, во время которых применяются алгоритмы оптимизаций), затем перевод HIR в LIR, снова оптимизации (уже на виртуальных регистрах памяти). Далее начинается бэкенд: выполняет перевод из LIR в машинный код, выбор инструкций, распределение физических регистров и кодогенерация (включающая точечные оптимизации/peephole rules) - в результате получается код на одном из языков Ассемблера (каждый язык уникален под свою архитектуру, но в большинстве своём они очень похожи).

Далее идёт работа самого Ассемблера, который из языка Ассемблера переводит код в объектный файл. После ассемблирования идёт работа линкера, который подключает сторонние библиотеки + объединяет объектные файлы в бинарный исполняемый файл. 


Вопрос 2. Построение CFG
