Это просто конспект теоретического материала с расписанными ответами на вопросы зачёта. Часть информации к ответам на зачёт будут брать отсюда (привет тому, кто это читает):

Вопрос 1. Общее устройство компилятора

Сама система компиляции (тулчейн) состоит из 3 основных элементов: самого компилятора, ассемблера и линкера. Сам компилятор при этом также делится на три части: фронтенд, миддленд и бэкенд, иногда миддленд считают частью фронтенда (вроде, устаревший подход). Лицевая часть компилятора (фротенд) получает код и выполняет три основных анализа: лексический, синтаксический и семантический. Лексический анализ выделяет основные лексемы (токены) из кода. В большинстве компиляторов токены представляют из себя пару вида "тип токена(например, тип данных, название переменной, rvalue-число и т.д.) + значение". Далее идёт синтаческий анализ/парсинг: происходит анализ потока лексем и построение на его основе AST - Abstract Syntax Tree/Синтаксического Дерево. Построение может быть неявным. Паралеллельно с синтаксическим анализом идёт семантический анализ: с помощью семантического анализатора, который оперерирует сохранённым контекстом на частичном AST, определяет, каким должен быть следующий узео, после чего в случае нарушения логики выдаёт сообщение о семантической ошибке. Затем идёт перевод AST в промежуточное представление (которое бывает двух видов - высокоуровневое HIR и низкоуровневое LIR, необходимые для машинно-независимых и машинно-зависимых оптимизаций соответственно). Сначала происходит перевод AST в HIR. В миддленде компилятора выполняются оптимизации для HIR (несколько проходов по коду, во время которых применяются алгоритмы оптимизаций), затем перевод HIR в LIR, снова оптимизации (уже на виртуальных регистрах памяти). Далее начинается бэкенд: выполняет перевод из LIR в машинный код, выбор инструкций, распределение физических регистров и кодогенерация (включающая точечные оптимизации/peephole rules) - в результате получается код на одном из языков Ассемблера (каждый язык уникален под свою архитектуру, но в большинстве своём они очень похожи).

Далее идёт работа самого Ассемблера, который из языка Ассемблера переводит код в объектный файл. После ассемблирования идёт работа линкера, который подключает сторонние библиотеки + объединяет объектные файлы в бинарный исполняемый файл. 


Вопрос 2. Построение CFG

Код переводится из линеаризированного представления в линеаризированный HIR. Базовым блоком (BB) называется последовательность инструкций HIR, в которую можно войти только в начале последовательности и выйти в конце (не считая вызов функций); BB заканчивается переходом в другой (другие) BB. Код из линеаризированного HIR разбивается на базовые BB. На основании этих базовых блоков и строится CFG, где каждая нода - это базовый блок, а ребро (направленное) показываетсяЮ что из BB #1 достижим BB #2.


Вопрос 3. Доминирование

Если рассмотреть два базовых блока (A и B, представимые в виде вершины), то A доминирует B, если любой путь от entry (точки входа) до B лежит через A. Строгое доминирование - если блок A это не блок B. Вершина A является непосредственным доминатором для B, если это ближайший доминатор (т.е. нет доминатора C, такого что B доминирует C, который доминирует A). Дерево доминирования - это ориентированное дерево, у которого рёбра соответствуют отношениям непосредственного доминирования. Фронтом доминирования вершины A называют множество узлов такое, что A не доминирует их строго и при этом доминирует одного из их предшественников (т.е. фронт - это все узлы, в которые идут рёбра из поддерева доминирования)

Вопрос 4..

SSA (Static Single Assignment) - это представление, в котором каждая переменная обладает одним и только одним определением, получаемым во время инициализации.

Например, код

...
int x = 3;
x++;
...

В SSA будем выглядеть примерно так

...
int x1 = 3;
int x2 = x1++;
...

Для того, чтобы в SSA можно было оперировать с переменной в ситуации, когда в одном базовом блоке значение хранится в x_n, а в другом - в x_m (для сведения переменных в SSA) применяют фи-узлы (фи-ноды). Например,

...
std::cin >> x; 
if (x > 10) {
    x = 10;
}
x += 2;
...

в SSA будет иметь вид (здесь псевдокод):

...
BB0: std::cin >> x1;
     if (x1 > 10) {
         goto BB1;}
     goto BB2;
     
BB1: int x2 = 10;
     goto BB2;

BB2: int x3 = phi_node(x1, BB0; x2, BB1);
     x4 = x3 + 2;
 ....
 
 
 Вопрос 5. Граф зависимостей SSA (SSA Graph)
 
 Граф завиимостей - это граф, вершинами которых являются определения переменных в SSA, а оринтированные рёбра присутствуют, если определение одно переменной использует другую переменную.
 
 Например, int x3 = phi_node(x1, BB0; x2, BB1) - здесь от x1 и x2 будут идти рёбра к x3. 
 
 Идея построения - DFS наоборот. Запускаем от последней переменной (среди иницилизированных, чтобы сэкономить ресурсы) и проверяем, какие она использует в определении. Строим рёбра от этих переменных к начальной. Проделываем тоже самое с начальными переменными. Все посещённые переменнные "помечаем". Если проход DFS закончился. Начинаем с последней по порядку непосещённой. Если в какой-то момент мы пришли в уже помеченную переменную, то просто соединяем два подграфа в один граф. Но важно помнить про то, что мы можем и не удалить неиспользуемый код.
 
 
 Вопрос 6.1 Свёртка и продвижение констант
 
 Свёртка контсант - оптимизация, вычисляющая константные значения на этапе компиляции. По сути, замена константы на числовое значение. Продвижение константы - оптимизация, при которой выражение, которое возвращает всегда одну и ту же константу, заменяется на эту константу
 
 Вопрос 6.2 Inline
 
 Оптимизация подстановки тела функции (inline) по сути представляет из себя замену вызова функции на сам код этой функций. Применяется, если функция используется относительно небольшое число раз. Плюс - избавляемся от лишней функции. Минус - если сделать слишком много замен, то код становится нечитаемым/плохо читаемым для человека
 
 Вопрос 6.3. Value Numbering / Нумерация значений
 
 Не совсем оптимизация. Скорее, анализ потока данных для дальнейших оптимизаций. Идея: что, если все операции возвращают одинаковый результат. 
 
 Код (нагло спёр из лекции К.Владимирова)
 
 int foo (int x, int y){
     a = x + y;
     b = x - y;
     c = a - b;
     d = x + y;
     return d + c;
 }
 
 Разобьём все операции по пакетам: Px = {x}, Py = {y}, P+ = {a, d}, P- = {b, c}, по факту - пронумеруем
 
 Две инструкции конгруэнты, если две инструкции принадлежат одному пакету и все их операнды попарно принадлежат одним и тем же пакетам. Если инструкции конгруэнты, то с огромной вероятность они и вовсе одинаковы. Тогда можно просто всё заменить на одинаковые операции с одинаковыми операндами (что сократит лишние переменные), после чего может быть использовано в комбинации с другими оптимизациями, например, inline
 
 Вопрос 6.4 Мёртвый код/Dead Code Elemination
 
 Код называется мёртвым, если он исполняется, но его результат не используется. Идея следующая - проходимся по CFG снизу вверх (от конечной процедуры до начальной, не в направлении исток->сток, а в направлении сток->исток). Всё, что не встретилось на пути, но при этом доминируется начальной процедурой - мёртвый код. Можем просто удалить эти вершины.
 
 Альтернативный способ удаления мёртвого кода:
 
 1. Помечаем все априори живые операции (переходы, запись в память, вызовы функций)
 2. Для каждой живой операции проходим по def-use графу, помечая все посещённые операции живым
 3. Оставшиеся непосещённые вершины просто удаляем

 
 Вопрос 6.5 Недостижимвй код/ Unreachable Code Elimination

Код называется недостижимым, если до него не дойдёт управление, независимо от входных данных. В CFG недостижимый код не имеет пути от стартового узла (не доминируется им). Недостижимый код просто удаляется, чтобы упростить человеку чтение программы. Нужно учитывать, что недостижимый код может пожет получиться после оптимизаций.
 
 Вопрос 7.1 Циклы
 
 В англоязычной литературе есть два термина для цикла: cycle и loop (петля). Cycle - любая последовательность блоков, такая, что, двигаясь по ней, мы можем вернуться в начальную точку. Loop - разновидность cycle без самопересечения блоков. Обратная дуга (back edge) - дуга из вершины m в вершину n, при этом n доминирует m. В условиях оптимизации компиляторов под циклом подразумевается loop
 
 Цикл состоит из:
 
-головы цикла (она одна для нашего цикла), в неё ведёт обратная дуга
-тела цикла (основные вершины в цикле)
-выходной вершины (выходного узла) - узла, из которого ведёт обратно ребро и выходная дуга
-входной и выходной дуг - дуг, которые вводят и выводят нас из цикла
 
 Естественный цикл (natural loop) - подграф CFG, в котором m -> n - это обратная дуга, при этом подграф состоит из всех узлов, из которых достижима вершина m, если стереть n (включая дугу). Если все компоненты сильной связности CFG являются естественными циклами, то CFG - сводимый, иначе - несводимый.
 
 Вопрос 7.2. Алгоритм построения дерева циклов (Loop Nesting Tree) по Хавлаку (та самая статья):
 
 1. DFS-нумерация узлов: выполняем обход CFG в глубину, начиная с START, каждому узлу присваиваем номер number[v] (порядок посещения) и сохраняем номер последнего потомка last[v] в поддереве DFS.
 2. Классификация рёбер: для каждого узла w разбиваем входящие рёбра на backPreds[w] – обратные рёбра (источник – потомок w в DFS) и nonBackPreds[w] – остальные рёбра (источник – не потомок w).
 3. Обработка узлов в обратном порядке DFS: для каждого узла w (от большего number к меньшему). Если w – цель обратных рёбер, он потенциально является заголовком цикла. Собираем множество P узлов цикла через FIND (используя структуру данных UNION-FIND для эффективного объединения множеств). Проверяем, есть ли пути в цикл, минуя w (через nonBackPreds). Если да, цикл неприводимый (type[w] = irreducible), иначе приводимый (type[w] = reducible). Объединяем узлы цикла в множество с заголовком w (UNION).
 4. Построение дерева циклов: для каждого узла x родителем в дереве становится header[x] (заголовок наименьшего цикла, содержащего x). Корнем дерева делаем START.

Также в статье рассматривался алгоритм fix_loops (нормализация). Проблема: заголовок приводимого цикла может совпадать с точкой входа неприводимого цикла, что мешает их корректному разделению. Решение: вставка фиктивных узлов для гарантии уникальности заголовков. Для каждого узла w с входящими приводимыми обратными рёбрами (redBackIn[w]) - если у w есть другие входящие рёбра (otherIn[w]), создаём новый узел w' и перенаправляем на него все рёбра, кроме обратных.

Вопрос 7.3. Индуктивные переменные, базовые индуктивные переменные

Индуктивности, они же индуктивные переменные, можно (в упрощённом виде) рассматривать как замкнутый путь в SSA-графе. Индуктивной переменной общего вида (обобщённой индуктивностью, generalized induction variable, GIV) является любой замкнутый путь в SSA представлении, все вершины которого находятся внутри естественного цикла.

Код/пример (опять же, спёрт из книги К.Владимирова):

// case A
for (int i = 0; i < 3; ++i)
use(i + 7);

// case B
for (int i = 7; i * i < 100; ++i)
use(i);

// case C
for (int i = 0, j = 0; i * j < 9; ++i, ++j)
use((i + j) / 2 + 7);

С точки зрения компилятора весь этот код - одинаковый.

Базовой индуктивной переменной (basic induction variable, BIV) является переменная, которая внутри цикла изменяется на константу, единожды за итерацию цикла, т.е. представима в виде x(n) = b(n – 1) + k. Можно сказать, что базовая индуктивность также может быть представима в виде арифметической прогрессии. Поиск базовых индуктивностей выполняется с помощью Loop Tree/Loop Nesting Tree (Дерева Циклов). Скалярная эволюция переменной - зависимость значения переменной от номера итерации.

Вопрос 7.4. Вынос инвариантного кода:

Код-пример:

int ans = 0;
for (int i = 0; i < 10; i++){
    int x = 10;
    int y = x * 4;
    int z = (x + y) * i;
    ans += z;
}

Идея заключается в том, что x у нас константа, y тоже, при этом значение y вычисляется с каждой итерации цикла. Код, который не зависит от итерации, называются инвариантом - его нужно выносить из цикла (либо на этапе разработки, либо, в нашем случае, в процессе оптимизации):

int ans = 0;
int x = 10;
int y = x * 4; //здесь ещё можем выполнить свёртку константы в рамках дальнейшей оптимизации
int z = x + y;
for (int i = 0; i < 10; i++){
    ans += (z * i); //опять же, можем пойти дальше и поиграть с оптимизацией, представим значение z*i, как отдельную базовую индуктивную переменную
}

Вопрос 7.5. Оставшиеся определения

Loop Unroll - раскрутка циклов. Заключается в том, чтобы от 1 до n раз вставить код цикла вместо самого цикла (сам цикл подразумевает n итераций), позволяет избавиться от итератора или открывает путь к другим оптимизациям. Полная раскрутка - раскрутка цикла в n повторяющихся блоков, когда знаем, сколько у нас итераций. Частичная размотка применяется, когда число итераций слишком велико, чтобы раскручивать цикл. Тогда выбирает фактор размотки N, так что n кратно N, смотрится результат после размотки N циклов и делается вывод, каким результат будет при применении кода n/N раз. Динамическая размотка цикла представляет из себя увеличение количество операций за одну итерацию цикла, служит при ОЧЕНЬ БОЛЬШОМ или неопределённом числе итераций, эффективна при параллельном программировании.

Loop Peeling - открутка итераций. Заключается в том, чтобы первую итерацию (реже N < n итераций) выполнить отдельно от самого цикла.

Loop splitting, distribusion, defusion - разбиение, распределение и слияние циклов (структурные оптимизации по К.Владимирову). Splitting - если в цикле есть проверка условия, разбиваем цикл на две части: где условие не выполнено, и где выполнено. Distribution - похожа на splitting, идея в том, чтобы работу одного цикла разделить на два (например, есть 2 переменные, которые не зависят друг от друга, зависят только от номера итерации и инварианта, тогда с одной переменной будут оперировать в одном цикле, а с другой - во втором). Defusion - операция, обратная distribution (слияние двух независимых циклов в один). 





